// for Shallow copy, 
// memberwise copy, the default way of copy generated by compiler
// say when both source and copy has pointer points to the same data on heap
// when copy destructor is called, you're done

// the Pointer is copied NOT what is points to (Shallow copy)

// consider a class that contains a pointer as a data member
// constructor allocates storage dynamically and initializes the pointer
// destructor releases the memory allocated bt the constrctor


// THIS CODE IS FOR DEMONSTRATION PURPOSES, IT WILL GENERATOR BUG AND CRASH
// THIS CODE IS FOR DEMONSTRATION PURPOSES, IT WILL GENERATOR BUG AND CRASH
// THIS CODE IS FOR DEMONSTRATION PURPOSES, IT WILL GENERATOR BUG AND CRASH

#include <iostream>
#include <string>
#include <vector>

using namespace std;

class Shallow {
private:
    int* dataPtr;
public:
    void set_data_value(int d) {*dataPtr = d;}
    int get_data_value() {return *dataPtr;}

    // constructor (prototype)
    Shallow (int d);
    // copy constructor (prototype)
    Shallow (const Shallow &source);
    // destructor
    ~Shallow();
};

// Shallow constructor implementation
Shallow::Shallow (int d){
    dataPtr = new int;
    *dataPtr = d;
}

// Shallow copy constructor implementation
Shallow::Shallow(const Shallow &source)
    : dataPtr(source.dataPtr) { // if : Shallow{*source.dataPtr}, then would be deep copy, and bug free
        cout << "Copy constructor - shallow copy" << endl;
}

// Shallow copy destructor implementation
Shallow::~Shallow(){
    delete dataPtr;
    cout << "Destructor freeing data" << endl;
}

void display_shallow (Shallow s){
    cout << s.get_data_value() << endl;
}

int main (void)
{
    Shallow obj1 {100};
    display_shallow(obj1);

    Shallow obj2 {obj1};
    // obj2.set_data_value(1000);
    display_shallow(obj2);


    return 0;
}